# План по нормализации данных

**Цель:** Преобразовать "сырые" извлеченные данные в единый, чистый и согласованный формат. Скрипт будет работать как самостоятельный шаг, подготавливая данные для дальнейшей обработки.

---

### **Шаг 1: Структура и файлы**

-   **Действие:** Создать скрипт `data_normalization/normalize_data.py`.
-   **Вход:** `data_normalization/input/final_json.json`.
-   **Выход:** `data_normalization/output/normalized_data.json`.

---

### **Шаг 2: Нормализация строки со значением (`value`)**

-   **Цель:** Преобразовать сложноформатированную строку `value` в единое числовое значение (`float`).
-   **Логика парсинга:**
    1.  **Очистка строки:** Удалить операторы сравнения (`<`, `>`, `≦`, `~`, `±`), пробелы, и привести к стандартному виду символы умножения (`x`, `×` -> `*`).
    2.  **Обработка чисел:** Удалить запятые-разделители тысяч (например, `1,234.5` -> `1234.5`).
    3.  **Обработка диапазонов:**
        -   Для форматов `0.1-1.0` или `5 to 10` — брать **верхнее значение** (т.е. `1.0` или `10`).
    4.  **Обработка научной нотации:** Распознать и вычислить различные форматы:
        -   `1x10^-8`, `3 X 10^-5`, `10^{-9}`, `8.0 E-8` и т.п.
    5.  **Итоговый результат:** Поле `value` будет содержать одно число типа `float`.

---

### **Шаг 3: Определение типа метрики (логарифмическая или линейная)**

-   **Цель:** Определить, является ли исходная метрика логарифмической, для правильной конвертации на следующем шаге.
-   **Логика:** Запись считается логарифмической, если **исходная** (до нормализации) строка `binding_metric` начинается с `p` или `log`, ИЛИ если в **исходной** строке `value` есть слово `log`. Это решение сохраняется во временной переменной.

---

### **Шаг 4: Нормализация названия метрики (`binding_metric`)**

-   **Цель:** Привести все варианты написания метрик к одному из **четырех стандартных** видов: `IC50`, `Ki`, `Kd`, `EC50`.
-   **Действия:**
    1.  Создать словарь для сопоставления всех возможных вариаций (включая `pIC50`, `log Ki` и т.д.) с их базовой формой.
        -   `{'ic-50', 'ic 50', 'ic₅₀', 'pic50'}` -> `"IC50"`
        -   `{'ki', 'pki'}` -> `"Ki"`
        -   `{'kd', 'pkd'}` -> `"Kd"`
        -   `{'ec-50', 'ec 50', 'ec₅₀', 'pec50'}` -> `"EC50"`
    2.  Заменить `binding_metric` на одно из четырех стандартных значений. Записи с другими метриками отфильтровываются.

---

### **Шаг 5: Финальная обработка и конвертация**

-   **Цель:** Применить правильную логику конвертации для логарифмических и линейных значений, чтобы привести все данные к единому формату (значение в nM).
-   **Логика:** Этот шаг выполняется после определения типа метрики (Шаг 3).

    1.  **Если метрика была определена как логарифмическая:**
        -   **Действие:** Применить формулу `value = (10 ^ (-value)) * 10^9`.
        -   **Действие:** Установить `unit` в `"nM"`.
        -   **Примечание:** Исходное поле `unit` для этих записей полностью игнорируется.

    2.  **Если метрика была определена как линейная:**
        -   **Действие 1: Нормализация `unit`**.
            -   Привести все варианты написания (`μm`, `micromolar` и т.д.) к одному из стандартных: `nM`, `uM`, `mM`, `pM`.
            -   *Словарь сопоставления:*
                -   `{'nm', 'nanomolar'}` -> `"nM"`
                -   `{'um', 'μm', 'micromolar'}` -> `"uM"`
                -   `{'mm', 'millimolar'}` -> `"mM"`
                -   `{'pm', 'picomolar'}` -> `"pM"`
        -   **Действие 2: Фильтрация**.
            -   Если исходный `unit` отсутствует или не может быть нормализован к одному из четырех стандартных, **отфильтровать** всю запись.
        -   **Действие 3: Конвертация `value`**.
            -   Применить соответствующий коэффициент для конвертации значения в наномоли.
            -   Установить `unit` в `"nM"`.

---

### **Примеры обработки**

| Тип поля | Исходное значение | Нормализованное значение / Результат | Итог |
| :--- | :--- | :--- | :--- |
| **`binding_metric`** | `"IC50"`, `"ic-50"`, `"ic 50"` | `"IC50"` (Линейный) | **Обработано** |
| | `"pKi"`, `"log(Ki)"` | `"Ki"` (Логарифмический) | **Обработано** |
| | `"binding"`, `"activity"` | - | **Отброшено** |
| **`value`** | `"<10"`, `"~5.5"` | `10.0`, `5.5` | **Обработано** |
| | `"10-20"`, `"5 to 10"` | `20.0`, `10.0` | **Обработано** |
| | `"1,234.5"` | `1234.5` | **Обработано** |
| | `"1.2 x 10^-7"` | `1.2e-7` | **Обработано** |
| | `"Not determined"`, `"N/A"` | - | **Отброшено** |
| **`unit`** (для лин. метрик) | `"nM"`, `"nanomolar"` | `"nM"` | **Обработано** |
| | `"μM"`, `"micromolar"` | `"uM"` | **Обработано** |
| | `None`, `""`, `"%"` | - | **Отброшено** |

---

### **Итоговый пайплайн (на данный момент):**

1.  **Агенты 1 и 2** -> `final_json.json`
2.  **(Вручную)** Скопировать `final_json.json` в `data_normalization/input/`.
3.  **Запустить `data_normalization/normalize_data.py`**
    -   **Результат:** `data_normalization/output/normalized_data.json`
4.  **(Далее)** Этот нормализованный файл можно будет использовать для скрипта обогащения.
