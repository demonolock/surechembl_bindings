# План по нормализации данных

**Цель:** Преобразовать "сырые" извлеченные данные в единый, чистый и согласованный формат. Скрипт будет работать как самостоятельный шаг, подготавливая данные для дальнейшей обработки.

---

### **Шаг 1: Структура и файлы**

-   **Действие:** Создать скрипт `data_normalization/normalize_data.py`.
-   **Вход:** `data_normalization/input/final_json.json`.
-   **Выход:** `data_normalization/output/normalized_data.json`.

---

### **Шаг 2: Нормализация единиц измерения (`unit`)**

-   **Цель:** Привести все единицы измерения к стандартному виду и отфильтровать неподдерживаемые.
-   **Действия:**
    1.  **Стандартизация:** Привести все вариации написания к единому формату.
        -   Пример: `μM`, `uM`, `µM` -> `uM`.
    2.  **Фильтрация:** Записи с неподдерживаемыми или сложными единицами (например, `μg/ml`, `%`, и т.д.) будут **отфильтрованы** и не войдут в итоговый файл.
    3.  **Конвертация в nM:** После стандартизации, все значения будут пересчитаны в наномоли (nM) с использованием коэффициентов:
        -   `uM` -> `* 1000`
        -   `mM` -> `* 1 000 000`
        -   `pM` -> `* 0.001`
        -   `nM` -> `* 1`
    4.  Поле `unit` у всех прошедших фильтрацию записей будет установлено в `"nM"`.

---

### **Шаг 3: Нормализация значений (`value`)**

-   **Цель:** Преобразовать сложноформатированную строку `value` в единое числовое значение (`float`).
-   **Логика парсинга:**
    1.  **Очистка строки:** Удалить операторы сравнения (`<`, `>`, `≦`, `~`, `±`), пробелы, и привести к стандартному виду символы умножения (`x`, `×` -> `*`).
    2.  **Обработка диапазонов:**
        -   Для форматов `0.1-1.0` или `5 to 10` — брать **верхнее значение** (т.е. `1.0` или `10`).
    3.  **Обработка научной нотации:** Распознать и вычислить различные форматы:
        -   `1x10^-8`, `3 X 10^-5`, `10^{-9}`, `8.0 E-8` и т.п.
    4.  **Итоговый результат:** Поле `value` будет содержать одно число типа `float`.

---

### **Шаг 4: Обработка логарифмических значений (pIC50, pKi)**

-   **Цель:** Перевести логарифмические значения в линейную шкалу (в наномолях).
-   **Действия:**
    1.  Использовать поле `is_logarithmic`.
    2.  Если `is_logarithmic` равно `true`, применить формулу: `value_nM = (10 ^ (-value)) * 10^9`.
    3.  После конвертации:
        -   `binding_metric` изменить (например, `pIC50` -> `IC50`).
        -   `is_logarithmic` установить в `false`.
        -   `unit` установить в `"nM"`.

---

### **Шаг 5: Нормализация названий метрик (`binding_metric`)**

-   **Цель:** Привести все варианты написания метрик к одному из **четырех стандартных** видов: `IC50`, `Ki`, `Kd`, `EC50`.
-   **Действия:**
    1.  Создать словарь для сопоставления всех возможных вариаций (включая логарифмические `pIC50` и т.д.) с их базовой формой.
        -   `{'ic-50', 'ic 50', 'ic₅₀', 'pic50'}` -> `"IC50"`
        -   `{'ki', 'pki'}` -> `"Ki"`
        -   `{'kd', 'pkd'}` -> `"Kd"`
        -   `{'ec-50', 'ec 50', 'ec₅₀', 'pec50'}` -> `"EC50"`
    2.  Заменить `binding_metric` на одно из четырех стандартных значений.

---

### **Итоговый пайплайн (на данный момент):**

1.  **Агенты 1 и 2** -> `final_json.json`
2.  **(Вручную)** Скопировать `final_json.json` в `data_normalization/input/`.
3.  **Запустить `data_normalization/normalize_data.py`**
    -   **Результат:** `data_normalization/output/normalized_data.json`
4.  **(Далее)** Этот нормализованный файл можно будет использовать для скрипта обогащения.
